1、朴素思路：找到有效的波峰和波谷
做法：现在找最大值，然后向两侧再找次大值，这就是一个有效的波峰和波谷
难度：如何判断结束条件（递归）
缺点：复杂度很大

2、改变思路：求某个位置能放上多少水，水量=左边最大值和右边最大值的最小值-当前数
实现一：对于左边最大值和右边最大值，利用遍历的方法获取，时间复杂度为O(n^2)
实现二：原数组为arr，提前准备两个数组，L和R，L[i]表示arr[0:i]的最大值，R[i]表示arr[i:(len(arr)-1)]的最大值
	遍历两次，时间复杂度为O(n)，空间复杂度为O(n)
        第一次从左到右遍历，求出L；第二次从右到左遍历，求出R
实现三：是实现二的简化，其实L数组是不必要的，因为我们在遍历原数组的过程中必然会知道左边的最大值（用变量记录）
	原数组为arr，提前准备一个数组R，R[i]表示arr[i:(len(arr)-1)]的最大值
	遍历一次，时间复杂度为O(n)，空间复杂度为O(n)
实现四：定义首尾两个指针=》数字位置，对于较小的那个值得那个位置的相邻位置，可以结算该位置能剩多少水
	时间复杂度为O(n)，空间复杂度为O(1)


对于实现一、二、四，都有代码实现，参考代码从而理解原理是最好的方法